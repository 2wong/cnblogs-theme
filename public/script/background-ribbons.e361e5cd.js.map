{"version":3,"file":"script/background-ribbons.e361e5cd.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kDAAkD,OAAO;AACzD;AACA;;AAEA;;AAEA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C,mEAAmE;AACnE;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA","sources":["webpack://cnblogs-theme/./src/components/background/ribbons.js"],"sourcesContent":["/**\n * UPDATES AND DOCS AT: https://github.com/wangyang0210\n * https://www.cnblogs.com/wangyang0210/\n * @author: WangYang, wangyang.0210@foxmail.com\n * @Date 2022-09-11 22:28\n * ----------------------------------------------\n * @describe: 背景丝带效果\n */\n\n\nclass Point {\n    constructor(x, y) {\n        this.x = 0;\n        this.y = 0;\n        this.set(x, y);\n    }\n\n\n    set(x, y) {\n        this.x = x || 0;\n        this.y = y || 0;\n    }\n\n    copy(point) {\n        this.x = point.x || 0;\n        this.y = point.y || 0;\n        return this;\n    }\n\n    add (x, y) {\n        this.x += x || 0;\n        this.y += y || 0;\n        return this;\n    }\n\n    subtract(x, y) {\n        this.x -= x || 0;\n        this.y -= y || 0;\n        return this;\n    }\n\n    flipY() {\n        this.y *= -1;\n        return this;\n    }\n\n}\n\n\nclass Ribbons {\n    _w = window;\n    _b = document.body;\n    _d = document.documentElement;\n\n    constructor(options) {\n        this._canvas = null;\n        this._context = null;\n        this._width = 0;\n        this._height = 0;\n        this._scroll = 0;\n        this._ribbons = [];\n        this._options = {\n            // ribbon color HSL saturation amount\n            colorSaturation: options.colorSaturation || \"80%\",\n            // ribbon color HSL brightness amount\n            colorBrightness: options.colorBrightness || \"60%\",\n            // ribbon color opacity amount\n            colorAlpha: options.colorAlpha || 0.65,\n            // how fast to cycle through colors in the HSL color space\n            colorCycleSpeed: options.colorCycleSpeed || 6,\n            // where to start from on the Y axis on each side (top|min, middle|center, bottom|max, random)\n            verticalPosition: options.verticalPosition || \"center\",\n            // how fast to get to the other side of the screen\n            horizontalSpeed: options.horizontalSpeed || 150,\n            // how many ribbons to keep on screen at any given time\n            ribbonCount: options.ribbonCount || 3,\n            // add stroke along with ribbon fill colors\n            strokeSize: options.strokeSize || 0,\n            // move ribbons vertically by a factor on page scroll\n            parallaxAmount: options.parallaxAmount || -0.5,\n            // add animation effect to each ribbon section over time\n            animateSections: options.animateSections || true\n        };\n\n        this._onDraw = this._onDraw.bind(this);\n        this._onResize = this._onResize.bind(this);\n        this._onScroll = this._onScroll.bind(this);\n        this.init();\n    }\n\n    random() {\n        if (arguments.length === 1) {\n            if (Array.isArray(arguments[0])) {\n                let index = Math.round(this.random(0, arguments[0].length - 1));\n                return arguments[0][index];\n            }\n            return this.random(0, arguments[0]); // assume numeric\n        }\n        if (arguments.length === 2) {\n            return Math.random() * (arguments[1] - arguments[0]) + arguments[0];\n        }\n\n        return 0;\n    }\n\n    // screen helper\n    screenInfo(e) {\n        let width = Math.max(0, this._w.innerWidth || this._d.clientWidth || this._b.clientWidth || 0),\n            height = Math.max(0, this._w.innerHeight || this._d.clientHeight || this._b.clientHeight || 0),\n            scrollx = Math.max(0, this._w.pageXOffset || this._d.scrollLeft || this._b.scrollLeft || 0) - (this._d.clientLeft || 0),\n            scrolly = Math.max(0, this._w.pageYOffset || this._d.scrollTop || this._b.scrollTop || 0) - (this._d.clientTop || 0);\n\n        return {\n            width: width,\n            height: height,\n            ratio: width / height,\n            centerx: width / 2,\n            centery: height / 2,\n            scrollx: scrollx,\n            scrolly: scrolly\n        };\n\n    }\n\n    init () {\n        try {\n            this._canvas = document.createElement(\"canvas\");\n            this._canvas.style[\"display\"] = \"block\";\n            this._canvas.style[\"position\"] = \"fixed\";\n            this._canvas.style[\"margin\"] = \"0\";\n            this._canvas.style[\"padding\"] = \"0\";\n            this._canvas.style[\"border\"] = \"0\";\n            this._canvas.style[\"outline\"] = \"0\";\n            this._canvas.style[\"left\"] = \"0\";\n            this._canvas.style[\"top\"] = \"0\";\n            this._canvas.style[\"width\"] = \"100%\";\n            this._canvas.style[\"height\"] = \"100%\";\n            this._canvas.style[\"z-index\"] = \"-1\";\n            this._canvas.id = \"bgCanvas\";\n            this._onResize();\n\n            this._context = this._canvas.getContext(\"2d\");\n            this._context.clearRect(0, 0, this._width, this._height);\n            this._context.globalAlpha = this._options.colorAlpha;\n\n            window.addEventListener(\"resize\", this._onResize);\n            window.addEventListener(\"scroll\", this._onScroll);\n            document.body.appendChild(this._canvas);\n        } catch (e) {\n            return;\n        }\n        this._onDraw();\n    }\n\n    addRibbon() {\n\n        let dir = Math.round(this.random(1, 9)) > 5 ? \"right\" : \"left\",\n            stop = 1000,\n            hide = 200,\n            min = 0 - hide,\n            max = this._width + hide,\n            movex = 0,\n            movey = 0,\n            startx = dir === \"right\" ? min : max,\n            starty = Math.round(this.random(0, this._height));\n\n        if (/^(top|min)$/i.test(this._options.verticalPosition)) starty = 0 + hide;\n        if (/^(middle|center)$/i.test(this._options.verticalPosition)) starty = this._height / 2;\n        if (/^(bottom|max)$/i.test(this._options.verticalPosition)) starty = this._height - hide;\n\n        let ribbon = [],\n            point1 = new Point(startx, starty),\n            point2 = new Point(startx, starty),\n            point3 = null,\n            color = Math.round(this.random(0, 360)),\n            delay = 0;\n\n        while (true) {\n\n            if (stop <= 0) break;\n            stop--;\n\n            movex = Math.round((Math.random() * 1 - 0.2) * this._options.horizontalSpeed);\n            movey = Math.round((Math.random() * 1 - 0.5) * (this._height * 0.25));\n\n            point3 = new Point();\n            point3.copy(point2);\n\n            if (dir === \"right\") {\n                point3.add(movex, movey);\n                if (point2.x >= max) break;\n            }\n\n            if (dir === \"left\") {\n                point3.subtract(movex, movey);\n                if (point2.x <= min) break;\n            }\n\n            ribbon.push({\n                point1: new Point(point1.x, point1.y),\n                point2: new Point(point2.x, point2.y),\n                point3: point3,\n                color: color,\n                delay: delay,\n                dir: dir,\n                alpha: 0,\n                phase: 0\n            });\n\n            point1.copy(point2);\n            point2.copy(point3);\n\n            delay += 4;\n            color += this._options.colorCycleSpeed;\n        }\n\n        this._ribbons.push(ribbon);\n    }\n\n    _drawRibbonSection(section) {\n        if (section) {\n            if (section.phase >= 1 && section.alpha <= 0) return true;\n\n            if (section.delay <= 0) {\n                section.phase += 0.02;\n                section.alpha = Math.sin(section.phase) * 1;\n                section.alpha = section.alpha <= 0 ? 0 : section.alpha;\n                section.alpha = section.alpha >= 1 ? 1 : section.alpha;\n\n                if (this._options.animateSections) {\n                    let mod = Math.sin(1 + section.phase * Math.PI / 2) * 0.1;\n\n                    if (section.dir === \"right\") {\n                        section.point1.add(mod, 0);\n                        section.point2.add(mod, 0);\n                        section.point3.add(mod, 0);\n                    } else {\n                        section.point1.subtract(mod, 0);\n                        section.point2.subtract(mod, 0);\n                        section.point3.subtract(mod, 0);\n                    }\n\n                    section.point1.add(0, mod);\n                    section.point2.add(0, mod);\n                    section.point3.add(0, mod);\n                }\n            } else {\n                section.delay -= 0.5;\n            }\n\n            let s = this._options.colorSaturation,\n                l = this._options.colorBrightness,\n                c = \"hsla(\" + section.color + \", \" + s + \", \" + l + \", \" + section.alpha + \" )\";\n\n            this._context.save();\n\n            if (this._options.parallaxAmount !== 0) this._context.translate(0, this._scroll * this._options.parallaxAmount);\n            this._context.beginPath();\n            this._context.moveTo(section.point1.x, section.point1.y);\n            this._context.lineTo(section.point2.x, section.point2.y);\n            this._context.lineTo(section.point3.x, section.point3.y);\n            this._context.fillStyle = c;\n            this._context.fill();\n\n            if (this._options.strokeSize > 0) {\n                this._context.lineWidth = this._options.strokeSize;\n                this._context.strokeStyle = c;\n                this._context.lineCap = \"round\";\n                this._context.stroke();\n            }\n\n            this._context.restore();\n        }\n        return false;\n    }\n\n    _onDraw() {\n\n        for (let i = 0, t = this._ribbons.length; i < t; ++i) {\n            if (!this._ribbons[i]) this._ribbons.splice(i, 1);\n        }\n\n        this._context.clearRect(0, 0, this._width, this._height);\n\n        for (let a = 0; a < this._ribbons.length; ++a) {\n            let ribbon = this._ribbons[a],\n                numSections = ribbon.length,\n                numDone = 0;\n            for (let b = 0; b < numSections; ++b) {\n                if (this._drawRibbonSection(ribbon[b])) numDone++; // section done\n            }\n            if (numDone >= numSections) this._ribbons[a] = null;\n        }\n\n        if (this._ribbons.length < this._options.ribbonCount) this.addRibbon();\n\n        requestAnimationFrame(this._onDraw);\n    }\n\n    _onResize(e) {\n        let screen = this.screenInfo(e);\n        this._width = screen.width;\n        this._height = screen.height;\n\n        if (this._canvas) {\n            this._canvas.width = this._width;\n            this._canvas.height = this._height;\n        }\n\n        if (this._canvas && this._context) this._context.globalAlpha = this._options.colorAlpha;\n    }\n\n    _onScroll(e) {\n        let screen = this.screenInfo(e);\n        this._scroll = screen.scrolly;\n    }\n}\n\nexport default function main(options) {\n    new Ribbons(options)\n}\n"],"names":[],"sourceRoot":""}